# 第4章 Kafka消费者-从kafka读取数据

## 4.1 KafkaConsumer概念

### 4.1.1 消费者和消费者群组

Kafka消费者从属于消费者群组，一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。

往群组里增加消费者是**横向伸缩消费能力**的主要方式。消费者经常会做一些高延迟的操作，比如将数据写入到数据库或HDFS，或者进行比较耗时的计算，单个消费者无法跟上数据生成的速度，所以需要增加更多消费者。但是要注意不要让消费者的数量超过主题分区的数量，**多余的消费者只会被闲置**。

除了通过增加消费者来横向伸缩单个应用程序外，还经常出现多个应用程序从同一个主题读取数据的情况。每个应用程序都可以获取到主题的所有消息。横向伸缩消费者和消费者群组并不会对性能造成负面影响。

新增的消费者群组G2会从主题T1接收到所有消息，与群组G1之间互不影响：

![](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/iShot2021-11-07%2020.34.58.png)

总而言之，为每一个需要获取一个或多个主题全部消息的应用程序创建一个消费者群组，然后往群组里添加消费者来伸缩读取能力和处理能力，群组里的每个消费者只处理一部分消息。

### 4.1.2 消费者群组和分区再均衡

分区的所有权从一个消费者转移到另一个消费者，这样的行为称为**再均衡**，它为消费者群组带来了高可用性和伸缩性（我们可以放心的添加或移除消费者）。但是在再均衡期间，消费者无法读取消息，造成整个群组一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，消费者当前的读取状态会丢失，还有可能需要去刷新缓存，在它恢复状态之前会拖慢应用程序。

消费者通过向被指派为**群组协调器**的broker（不同的群组可以有不同的协调器）发送心跳来维持它们和群组的从属关系以及它们对分区的所有权关系。只要消费者以正常的时间间隔发送心跳，就被认为是活跃的，说明它还在读取分区里的消息。消费者会在轮询消息（为了获取消息）或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。

如果 个消费者发生崩愤，井停止读取消息，群组协调器会等待几秒钟，确认它死亡了才触发再均衡。在这几秒钟时间里，死掉的消费者不会读取分区里的消息。在清理消费者时，消费者会通知协调器它将要离开群组，协调器会立即触发一次再均衡，尽量降低处理停顿。

**分配分区是怎样的一个过程**

当消费者要加入群组时，它会向群组协调器发送 Join Group 请求。第一个加入群组的消费者将成为“群主”。群主从协调器那里获得群组的成员列表（列表中包含了所有最近发送过心跳的消费者，它们被认为是活跃的），并负责给每一个悄费者分配分区。它使用一个实现了patitionAssignor接口的类来决定哪些分区应该被分配给哪个消费者。分配完毕之后，群主把分配情况列表发送给群组协调器，协调器再把这些信息发送给所有消费者。每个消费者只能看到自己的分配信息，只有群主知道群组里所有消费者的分配信息。这个过程会在每次再均衡时重复发生。

## 4.2 创建Kafka消费者

![](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/iShot2021-11-07%2022.28.38.png)

group.id属性指定了消费者所属群组的名字。创建不属于任何一个群组的消费者也是可以的，只是不常见。

## 4.3 订阅主题

创建好消费者之后就可以订阅主题了:

```java
consumer.subscibe(Collections.singletonlist("customerCountries"));
```

可以传入一个正则表达式，正则表达式可以匹配多个主题，如果创建了新主题并且名字与正则表达式匹配，那么会立即触发一次再均衡，消费者就可以读取新添加的主题。如果应用程序需要读取多个主题，并且可以处理不同类型的数据，那么这种订阅方式很管用，例如：

```java
consumer.subscribe("test.*");
```

## 4.4 轮询

