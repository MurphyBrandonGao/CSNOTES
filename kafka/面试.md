一、如何保证消息不丢失？即可靠性保证

生成者：

1、取消发送即忘模式，改为同步发送，或者异步发送，回调函数检查发送失败原因后重新发送即可；

2、设置重试次数，当因为网络原因发送失败的话可以自动重试发送。

消费者：

1、在自动提交 offset 模式下一拉取到消息就会自动提交偏移量。关闭自动提交，改为消费完消息之后再手动提交offset（但是会导致重复消费问题）。

Broker:

1、acks = all，leader和所有同步副本都收到消息（写入数据文件）后才返回确认。

2、设置 replication.factor >= 3：每个分区的副本数量最少3个，

3、设置 min.insync.replicas >= 2：每个分区最少同步副本2个，当少于2个时会写入失败。

二、消息保证不重复消费？

1、幂等处理

- 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
- 比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。
- 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
- 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

2、关闭自动提交



## B+树和B树比较

### 1、更矮胖

B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

### 2、范围查询

B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助

### 3、查询效率稳定

任何关键字的查找必定有一条从根节点到叶子节点的路径。所以关键字查询的长度相同，导致每个数据的查找效率也几乎是相同的稳定的，都是0log(n)

### 4、插入和删除效率更高

B+ 树的插入和删除效率更高