# 03 高性能IO模型

Redis 是单线程，主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成的**，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

## Redis为什么用单线程

### 多线程的开销

通常情况下，在我们采用多线程后，如果没有良好的系统设计，刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

io密集型非常适合多线程模式，如果多线程在cpu密集型情况下**频繁切换线程**带来性能损耗，反而不如单线程的性能，同时**多线程对共享资源的并发访问控制**也是一个可能拖累性能的点，两者处理起来都比较棘手。

并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加，反而增加了进程间的切换的开销。

而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。

## 单线程Redis为什么那么快

redis单线程模型能达到处理数十万级别的处理能力

1. Redis大部分操作在内存上完成，并且采用了高效的数据结构
2. 采用了多路复用机制，使其在网络IO操作中能并发处理大量客户端请求，实现高吞吐率。

### 基本IO模型与阻塞点

为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/e18499ab244e4428a0e60b4da6575bc9.jpg)

accept() 和 recv()是阻塞的，这就可能会导致Redis整个线程阻塞，无法处理其他客户端请求，效率很低。

### 非阻塞模式



