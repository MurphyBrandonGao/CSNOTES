# 岛屿

## 一、岛屿数量

第200题：岛屿数量

**为什么每次遇到岛屿，都要用 DFS 算法把岛屿「淹了」呢？主要是为了省事，避免维护 `visited` 数组**。

因为 `dfs` 函数遍历到值为 `0` 的位置会直接返回，所以只要把经过的位置都设置为 `0`，就可以起到不走回头路的作用。

```java
class Solution {
    private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    //每发现一个岛屿，就把岛屿数量加一
                    res++;
                    //再把岛屿给淹了
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
  
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    private void dfs(char[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        //已经是海水了，直接返回
        if (grid[i][j] == '0') {
            return;
        }
        //将（i, j) 淹没
        grid[i][j] = '0';
        //将上下左右的陆地淹了
        for (int[] direc : direction) {
            dfs(grid, i + direc[0], j + direc[1]);
        }
    }
}
```

## 二、封闭岛屿的数量

第1254题：统计封闭岛屿的数量

**那么如何判断「封闭岛屿」呢？其实很简单，把上一题中那些靠边的岛屿排除掉，剩下的不就是「封闭岛屿」了吗**？

```java
class Solution {
    private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public int closedIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            // 把靠左边的岛屿淹没
            dfs(grid, i, 0);
            // 把靠右边的岛屿淹没
            dfs(grid, i, n - 1);
        }
        for (int i = 0; i < n; i++) {
            // 把靠上边的岛屿淹没
            dfs(grid, 0, i);
            // 把靠下边的岛屿淹没
            dfs(grid, m - 1, i);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    //每发现一个岛屿，就把岛屿数量加一
                    res++;
                    //再把岛屿给淹了
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
  
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    private void dfs(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        //已经是海水了，直接返回
        if (grid[i][j] == 1) {
            return;
        }
        //将（i, j) 淹没
        grid[i][j] = 1;
        //将上下左右的陆地淹了
        for (int[] direc : direction) {
            dfs(grid, i + direc[0], j + direc[1]);
        }
    }
}
```

## 三、岛屿的最大面积

第695题：岛屿的最大面积

**这题的大体思路和之前完全一样，只不过 `dfs` 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积**。

我们可以给 `dfs` 函数设置返回值，记录每次淹没的陆地的个数，

```java
class Solution {
    private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    //把岛屿给淹了，并更新岛屿面积
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }
  
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水，并返回淹没的陆地面积
    private int dfs(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return 0;
        }
        //已经是海水了，直接返回
        if (grid[i][j] == 0) {
            return 0;
        }
        //将（i, j) 淹没
        grid[i][j] = 0;
        int area = 1;
        //将上下左右的陆地淹了
        for (int[] direc : direction) {
            area += dfs(grid, i + direc[0], j + direc[1]);
        }
        return area;
    }
}
```

