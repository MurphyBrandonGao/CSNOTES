# 回文

## 一、回文子串数量

第 647 题回文子串：给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

### 1、双指针法

```java
class Solution {
    private int cnt = 0;
    public int countSubstrings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        for (int i = 0; i < s.length(); i++) {
            extendString(s, i, i);
            extendString(s, i, i + 1);
        }
        return cnt;
    }
    private void extendString(String s, int l, int r) {
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
            cnt++;
        }
    }
}
```

## 2、动态规划

```java
class Solution {
    public int countSubstrings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int res = 0;
        for (int i = 0; i < n; i++) {
            char a = s.charAt(i);
            for (int j = 0; j <= i; j++) {
                char b = s.charAt(j);
                if (a == b) {
                    if (i - j < 3) {
                        dp[j][i] = true;
                        res++;
                    } else if (dp[j + 1][i - 1]) {
                        dp[j][i] = true;
                        res++;
                    }
                }
            }
        }
        return res;
    }
}
```

## 二、最长回文子串

第 5 题 最长回文子串：给你一个字符串 `s`，找到 `s` 中最长的回文子串。

### 1、双指针法

```java
String longestPalindrome(String s) {
    String res = "";
    for (int i = 0; i < s.length(); i++) {
        // 以 s[i] 为中心的最长回文子串
        String s1 = palindrome(s, i, i);
        // 以 s[i] 和 s[i+1] 为中心的最长回文子串
        String s2 = palindrome(s, i, i + 1);
        // res = longest(res, s1, s2)
        res = res.length() > s1.length() ? res : s1;
        res = res.length() > s2.length() ? res : s2;
    }
    return res;
}

// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
String palindrome(String s, int l, int r) {
    // 防止索引越界
    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
        // 双指针，向两边展开
        l--; 
        r++;
    }
    // 返回以 s[l] 和 s[r] 为中心的最长回文串
    return s.substring(l + 1, r);
}
```

## 三、最长回文子序列

### 1、动态规划

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
```

