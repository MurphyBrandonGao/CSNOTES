# 02 数据结构： 快速的Redis有哪些慢操作？

Redis收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。redis表现突出的原因：

1. 它是内存数据库，所有操作都在内存中完成；
2. 高效的数据结构。操作键值对最终是对数据结构的增删改查。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/8219f7yy651e566d47cc9f661b399f01.jpg)

String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为**集合类型**，它们的特点是**一个键对应了一个集合的数据。**

## 键和值用什么结构组织

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。

哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)

因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。

## 为什么哈希表操作变慢了？

哈希冲突：**两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中**。

解决哈希冲突的方式是链式哈希：**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。这样就形成了一个链表，叫作哈希冲突链。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/8ac4cc6cf94968a502161f85d072e428.jpg)

Redis会对哈希表做rehash操作。rehash即增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。

但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了**渐进式 rehash**。

在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/73fb212d0b0928d96a0d7d6ayy76da0c.jpg)

这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

一次请求迁移一个桶的entrys，那后续如果再也没有请求来的时候，余下的entrys是怎么处理的呢？是就留在hash1中了还是有定时任务后台更新过去呢？渐进式rehash执行时，除了根据请求来迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。

## 集合数据操作效率

和String类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。集合的操作效率与下列因素有关：

1. 与集合的底层数据结构有关
2. 操作本身的执行特点

### 有哪些底层数据结构

集合类型的底层数据结构主要有5种：整数数组、双向链表、哈希表、压缩列表和跳表。

#### 压缩列表

压缩列表实际上类似于一个数组，但和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/9587e483f6ea82f560ff10484aaca4a0.jpg)

如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。

相比数组压缩列表最大的优势就是ziplist**每个元素的占用空间是可变的**，按实际数据大小分配，**节省空间和减少内存碎片化**。虽然牺牲了数组的元素随机访问特点，但借助ziplist中的zltail_offset可以在访问时直接定位到尾部，以及**元素entry中也存储了每一个元素的len**，从而对list的双向遍历，lpush，lpop等操作提供了支持。

#### 跳表

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

跳表的查找复杂度是 O(logN)

### 数据结构的时间复杂度

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)

#### 不同操作的复杂度

- 单元素操作是基础；
- 范围操作非常耗时；
- 统计操作通常高效；
- 例外情况只有几个

1. 单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。
2. 范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了**渐进式遍历**，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就**避免了一次性返回所有元素而导致的 Redis 阻塞**。
3. 统计操作，是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。
4. 例外情况，是指某些数据结构的特殊记录，例如**压缩列表和双向链表都会记录表头和表尾的偏移量**。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

1. 内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。
2. 数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。