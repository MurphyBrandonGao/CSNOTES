# 09 切片集群：数据增多了，是该加内存还是加实例？

## 如何保存更多数据

- **纵向扩展（scale up）**：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。

  优点：**实施起来简单直接**

  缺点：1.主线程fork子进程时可能会阻塞  2.会受到硬件和成本的限制

- **横向扩展（scale out）**：横向增加当前 Redis 实例的个数。在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择

  优点：只用增加 Redis 实例个数就行，不用担心单个实例的硬件和成本限制

  缺点：复杂性高。数据切片后，在多个实例之间如何分布？客户端怎么确定想要访问的数据在哪个实例上？

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/7a512fec7eba789c6d098b834929701a.jpg)

## 数据切片和实例的对应分布关系

首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽

16384个哈希槽怎么分布到多个实例中？

1. 使用 cluster create 命令创建集群，Redis 会自动把这些槽平均分布在集群实例上。每个实例上的槽个数为 16384/N 个。
2. 使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/7d070c8b19730b308bfaabbe82c2f1ab.jpg)

**在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。**

## 客户端如何定位数据

集群创建时，Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端和集群实例建立连接后，实例就会吧哈希槽的分配信息发送给客户端。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就给对应的实例发送请求。

但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：

1. 在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；
2. 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。

此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但客户端无法主动感知这些变化。

Redis Cluster 方案提供了一种**重定向机制**。

客户端给一个实例发送数据读写操作时，如果这个实例上并没有这个键值对映射的哈希槽，这个实例会给客户端 MOVED 命令响应的结果，这个结果中就包含了新实例的访问地址。客户端再和新实例连接并发送操作请求，并更新本地缓存。

```
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```

![img](https://typora-gao-pic.oss-cn-beijing.aliyuncs.com/350abedefcdbc39d6a8a8f1874eb0809.jpg)

客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息：

```
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```

这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。

ASK 命令表示两层含义：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。

和 MOVED 命令不同，**ASK 命令并不会更新客户端缓存的哈希槽分配信息**。





Redis Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因： 

1、整个集群存储key的数量是无法预估的，key的数量非常多时，直接记录每个key对应的实例映射关系，这个映射表会非常庞大，这个映射表无论是存储在服务端还是客户端都占用了非常大的内存空间。 

2、Redis Cluster采用无中心化的模式（无proxy，客户端与服务端直连），客户端在某个节点访问一个key，如果这个key不在这个节点上，这个节点需要有纠正客户端路由到正确节点的能力（MOVED响应），这就需要节点之间互相交换路由表，每个节点拥有整个集群完整的路由关系。如果存储的都是key与实例的对应关系，节点之间交换信息也会变得非常庞大，消耗过多的网络资源，而且就算交换完成，相当于每个节点都需要额外存储其他节点的路由表，内存占用过大造成资源浪费。 

3、当集群在扩容、缩容、数据均衡时，节点之间会发生数据迁移，迁移时需要修改每个key的映射关系，维护成本高。 

4、而在中间增加一层哈希槽，可以**把数据和节点解耦**，key通过Hash计算，只需要关心映射到了哪个哈希槽，然后再通过哈希槽和节点的映射表找到节点，相当于**消耗了很少的CPU资源，不但让数据分布更均匀，还可以让这个映射表变得很小，利于客户端和服务端保存，节点之间交换信息时也变得轻量**。 

5、当集群在扩容、缩容、负载均衡时，节点之间的操作例如数据迁移，都以哈希槽为基本单位进行操作，简化了节点扩容、缩容的难度，便于集群的维护和管理。