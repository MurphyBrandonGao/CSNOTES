# MySQL调优之SQL语句：如何写出高性能SQL语句？

## 一、慢SQL语句的几种常见诱因

### 1、无索引、索引失效导致慢查询

### 2、锁等待

如果数据库操作是基于表锁实现的，如果一张订单表在更新时，需要锁住整张表， 那么其它大量数据库操作(包括查询)都将处于等待状态，这将严重影响到系统的并发性 能。

MySQL 认为如果对一张表使用大量行锁，会导致事务执行效率下降，从而可能造成其它事务长时间锁等待和更多的锁冲突问题发生，致使性能严重下降，所以 MySQL 会将行锁升级为表锁。还有，行锁是基于索引加的锁，如果我们在更新操作时，条件索引失效，那么行锁也会升级为表锁。

### 3、不恰当的SQL语句

使用不恰当的 SQL 语句也是慢 SQL 最常见的诱因之一。例如，习惯使用 <SELECT *>， <SELECT COUNT(**)> SQL 语句，在大数据表中使用 <LIMIT M,N> 分页查询，以及对非 索引字段进行排序等等。

## 二、优化SQL语句的步骤

### 1、通过EXPLAIN分析SQL执行计划

### 2、通过 show profile 分析SQL执行性能

Profile 除了可以分析执行线程的状态和时间，还支持进一步选择 ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES 等类型来查询 SQL 语句在不同系统资源上所消耗的时间。

## 三、常用的SQL优化

### 1、优化分页查询

通常我们是使用 <LIMIT M,N> + 合适的 order by 来实现分页查询，这种实现方式在没有 任何索引条件支持的情况下，需要做大量的文件排序操作(file sort)，性能将会非常得糟糕。如果有对应的索引，通常刚开始的分页查询效率会比较理想，但越往后，分页查询的性能就越差。

这是因为在使用 LIMIT 的时候，偏移量 M 在分页越靠后的时候，值就越大，数据库检索的数据也就越多。例如 LIMIT 10000,10 这样的查询，数据库需要查询10010条记录。最后返回10条记录。有10000条记录被查询出来没有被使用到。

```sql
select * from 'demo'.'order' order by order_no limit 10000, 20;
```

利用子查询优化分页查询

以上分页查询的问题在于，我们查询获取的 10020 行数据结果都返回给我们了，我们能否先查询出所需要的 20 行数据中的最小 ID 值，然后通过偏移量返回所需要的 20 行数据给我们呢？我们可以通过索引覆盖扫描，使用子查询的方式来实现分页查询：

```sql
select * from `demo`.`order` where id > (select id from `demo`.`order` order by order_no limit 10000, 1)  limit 20;
```

### 2、优化select count(*)

- 使用近似值

有时候某些业务场景并不需要返回一个精确的 COUNT 值，此时我们可以使用近似值来代替。我们可以使用 EXPLAIN 对表进行估算，要知道，执行 EXPLAIN 并不会真正去执行查询，而是返回一个估算的近似值。

- 增加汇总统计

如果需要一个精确的 COUNT 值，我们可以额外新增一个汇总统计表或者缓存字段来统计需要的 COUNT 值，这种方式在新增和删除时有一定的成本，但却可以大大提升 COUNT() 的性能。

### 3、优化 select *

假设我们的订单表是基于 InnoDB 存储引擎创建的，且存在 order_no、status 两列组成的组合索引。此时，我们需要根据订单号查询一张订单表的 status，如果我们使用 select * from order where order_no='xxx’来查询，则先会查询组合索引，通过组合索引获取到主键 ID，再通过主键 ID 去主键索引中获取对应行所有列的值。

如果我们使用 select order_no, status from order where order_no='xxx’来查询，则只会查询组合索引，通过组合索引获取到对应的 order_no 和 status 的值。